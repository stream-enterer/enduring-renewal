{
  "current": {
    "file": "TestParty",
    "method": null,
    "status": "not_started",
    "hypothesis": null,
    "verified": null
  },
  "blocked": [
    {
      "file": "TestKeyword",
      "method": "rampageHeroKill",
      "reason": "Requires die/sides system (turnInto) and isUsed() state tracking. Tests that Rampage keyword keeps die unused when it kills something.",
      "timestamp": "2025-01-10T22:00:00Z"
    },
    {
      "file": "TestKeyword",
      "method": "testComboCruelWand",
      "reason": "Requires die/sides system (turnInto) and copycat keyword. Tests copycat picks up keywords from wandFire.",
      "timestamp": "2025-01-10T22:00:00Z"
    },
    {
      "file": "TestKeyword",
      "method": "testComboCruel",
      "reason": "Requires die/sides system (turnInto) and copycat keyword. Tests copycat picks up keywords from copied effects.",
      "timestamp": "2025-01-10T22:00:00Z"
    },
    {
      "file": "TestKeyword",
      "method": "precisePlusMagic",
      "reason": "Requires mana system (shieldMana, getTotalMana) and buff/keyword application system (AffectSides, AddKeyword).",
      "timestamp": "2025-01-10T21:30:00Z"
    },
    {
      "file": "TestKeyword",
      "method": "rescue",
      "reason": "Requires die 'used' state tracking (isUsed()). Rescue keyword: heal doesn't mark die as used if it rescued target from dying.",
      "timestamp": "2025-01-10T19:35:00Z"
    },
    {
      "file": "TestKeyword",
      "method": "growth",
      "reason": "Requires die/sides system (turnInto, DieCommand) and mana system (getTotalMana, shieldMana effect). Growth makes effect value increase by 1 each use (1 -> 2 -> 3 -> etc).",
      "timestamp": "2025-01-10T19:35:00Z"
    },
    {
      "file": "TestComplexEff",
      "method": "petrifyBug",
      "reason": "Requires die/sides system. Petrify removes die sides, cleanse restores them. Need to implement die infrastructure first.",
      "timestamp": "2025-01-10T18:40:00Z"
    },
    {
      "file": "TestComplexEff",
      "method": "copycatManagain",
      "reason": "Requires mana system and copycat keyword (copies last used effect).",
      "timestamp": "2025-01-10T19:00:00Z"
    },
    {
      "file": "TestComplexEff",
      "method": "pair",
      "reason": "Requires mana system and pair keyword (bonus mana when rolling same effect twice).",
      "timestamp": "2025-01-10T19:00:00Z"
    },
    {
      "file": "TestComplexEff",
      "method": "petrifyAboveSix",
      "reason": "Requires die/sides system. Petrify capped at 6 sides.",
      "timestamp": "2025-01-10T19:00:00Z"
    }
  ],
  "completed": [
    {
      "file": "TestKeywordSpell",
      "method": "cruel",
      "hypothesis": "Cruel keyword applies x2 multiplier to HEALS when target is at <= half HP (HP <= maxHP/2).",
      "verified": "Confirmed.",
      "test": "tests/test_keyword.py::TestCruelHeal",
      "timestamp": "2025-01-10T22:20:00Z"
    },
    {
      "file": "TestKeywordSpell",
      "method": "engage",
      "hypothesis": "Engage keyword works with spells the same way as with dice (x2 vs full HP targets).",
      "verified": "Already covered - our implementation is source-agnostic. Effects work the same whether from dice or spells. Engage verified in TestKeyword.precise.",
      "test": "tests/test_keyword.py::TestEngage",
      "timestamp": "2025-01-10T22:10:00Z"
    },
    {
      "file": "TestKeyword",
      "method": "pain",
      "hypothesis": "dmgPain(N) deals damage to target AND damages the user for N.",
      "verified": "Already verified and implemented in TestStrangeScenarios.painShouldKill.",
      "test": "tests/test_strange_scenarios.py::test_pain_damages_user, test_pain_can_kill_user",
      "timestamp": "2025-01-10T22:00:00Z"
    },
    {
      "file": "TestKeyword",
      "method": "regen",
      "hypothesis": "healRegen(N) heals N immediately AND applies a persistent regen buff. The buff heals N HP at the start of each subsequent turn. Healing is capped at max HP.",
      "verified": "Confirmed.",
      "test": "tests/test_keyword.py::TestRegen",
      "timestamp": "2025-01-10T21:45:00Z"
    },
    {
      "file": "TestKeyword",
      "method": "lifestealVsInvincible",
      "hypothesis": "Dodge buff makes target immune to damage, but drain/selfHeal still heals the user by the intended amount regardless of whether damage was dealt.",
      "verified": "Confirmed.",
      "test": "tests/test_keyword.py::TestLifestealVsInvincible",
      "timestamp": "2025-01-10T21:30:00Z"
    },
    {
      "file": "TestKeyword",
      "method": "drain",
      "hypothesis": "Drain/SelfHeal is a damage keyword that deals damage to target AND heals the attacker by the same amount. Example: drain(1) deals 1 damage to target and heals user by 1.",
      "verified": "Confirmed.",
      "test": "tests/test_keyword.py::TestDrain",
      "timestamp": "2025-01-10T21:15:00Z"
    },
    {
      "file": "TestKeyword",
      "method": "weaken",
      "hypothesis": "Weaken deals damage AND reduces target's outgoing damage by N. Affects pending damage from that source (3 pending - 2 weaken = 1 pending).",
      "verified": "Confirmed.",
      "test": "tests/test_keyword.py::TestWeaken",
      "timestamp": "2025-01-10T21:00:00Z"
    },
    {
      "file": "TestKeyword",
      "method": "fierce",
      "hypothesis": "Test is misnamed - actually tests Cruel keyword. Cruel deals x2 damage vs targets at half HP or less (HP <= maxHP/2).",
      "verified": "Confirmed. When monster at half HP, cruel triggers x2.",
      "test": "tests/test_keyword.py::TestCruel",
      "timestamp": "2025-01-10T20:00:00Z"
    },
    {
      "file": "TestKeyword",
      "method": "precise",
      "hypothesis": "Engage deals x2 damage against targets at full HP. Once they're damaged (HP < maxHP), no multiplier applies.",
      "verified": "Confirmed. Engage = x2 vs targets with full hp (from keywords.csv).",
      "test": "tests/test_keyword.py::TestEngage",
      "timestamp": "2025-01-10T19:50:00Z"
    },
    {
      "file": "TestKeyword",
      "method": "poison",
      "hypothesis": "Poison is a damage keyword that deals immediate damage AND adds pending damage equal to the poison amount. Example: dmgPoison(1) deals 1 damage now and 1 more at turn end (in future state).",
      "verified": "Confirmed.",
      "test": "tests/test_keyword.py::TestPoison",
      "timestamp": "2025-01-10T19:40:00Z"
    },
    {
      "file": "TestKeyword",
      "method": "bloodlust",
      "hypothesis": "Bloodlust is a damage keyword that gains +N bonus damage where N = number of currently damaged enemies. The count is evaluated at time of attack. Damaging a new enemy increases future bonus; killing an enemy decreases it.",
      "verified": "Confirmed. Bonus equals count of damaged enemies at time of attack, not cumulative uses.",
      "test": "tests/test_keyword.py::TestBloodlust",
      "timestamp": "2025-01-10T19:30:00Z"
    },
    {
      "file": "TestComplexEff",
      "method": "goblinFlee",
      "hypothesis": "Goblins flee when they become the only remaining enemy after an ally dies. Fleeing removes them from battle (counts as victory).",
      "verified": "Confirmed.",
      "test": "tests/test_complex_eff.py::TestGoblinFlee",
      "timestamp": "2025-01-10T19:10:00Z"
    },
    {
      "file": "TestComplexEff",
      "method": "fortitudeHeal",
      "hypothesis": "healVitality(N) heals by N AND increases max HP by N. HP capped at new max. Example: 2/4 + healVitality(3) = 5/7.",
      "verified": "Confirmed.",
      "test": "tests/test_complex_eff.py::TestVitality",
      "timestamp": "2025-01-10T18:50:00Z"
    },
    {
      "file": "TestComplexEff",
      "method": "resurrect",
      "hypothesis": "resurrect(N) brings back up to N dead heroes with full HP. Capped at number of dead. Resurrected heroes can't roll dice that turn.",
      "verified": "Confirmed.",
      "test": "tests/test_complex_eff.py::TestResurrect",
      "timestamp": "2025-01-10T18:30:00Z"
    },
    {
      "file": "TestComplexEff",
      "method": "stoneskin",
      "hypothesis": "StoneSpecialHp (stoneskin) buff caps ALL incoming damage to 1 per hit. Some units have varying amounts - can vary in location and amount of stone HP pips.",
      "verified": "Confirmed.",
      "test": "tests/test_complex_eff.py::TestStoneskin",
      "timestamp": "2025-01-10T18:15:00Z"
    },
    {
      "file": "TestComplexEff",
      "method": "keepShield",
      "hypothesis": "Shields normally clear at end of turn. KeepShields buff prevents shield decay - shields persist across turns.",
      "verified": "Confirmed.",
      "test": "tests/test_complex_eff.py::TestKeepShields",
      "timestamp": "2025-01-10T18:00:00Z"
    },
    {
      "file": "TestComplexEff",
      "method": "doubleTaunt",
      "hypothesis": "Redirect(N) moves ALL incoming damage from target ally to the redirector. Redirect has selfShield keyword granting N shields to redirector. Shields then block redirected damage. Multiple redirects stack shields.",
      "verified": "Confirmed. Redirect moves all damage to taunter. selfShield keyword provides the damage reduction via shields.",
      "test": "tests/test_complex_eff.py::TestRedirect",
      "timestamp": "2025-01-10T17:45:00Z"
    },
    {
      "file": "TestComplexEff",
      "method": "pain",
      "hypothesis": "dmgPain effect damages both the target and the user.",
      "verified": "Already verified and implemented in TestStrangeScenarios.painShouldKill and painDrainNiceness.",
      "test": "tests/test_strange_scenarios.py::test_pain_damages_user, test_pain_can_kill_user",
      "timestamp": "2025-01-10T17:30:00Z"
    },
    {
      "file": "TestItem",
      "method": "testBonusIncomingWithHealShields",
      "hypothesis": "IncomingEffBonus modifies effects RECEIVED by the entity. Garnet adds +1 incoming heal, Iron Pendant adds +1 incoming shield.",
      "verified": "Confirmed.",
      "test": "tests/test_item.py::test_bonus_incoming_with_heal_shields",
      "timestamp": "2025-01-10T17:00:00Z"
    },
    {
      "file": "TestItem",
      "method": "testPipeAndStudsWithHealShield",
      "hypothesis": "Combined effect types like HEAL_SHIELD match both Heal and Shield type conditions. Multiple item bonuses stack on a single side.",
      "verified": "Confirmed. Fighter has 5 HP.",
      "test": "tests/test_item.py::test_pipe_and_studs_with_heal_shield",
      "timestamp": "2025-01-10T16:40:00Z"
    },
    {
      "file": "TestItem",
      "method": "testSteelHeart",
      "hypothesis": "OnRescue trigger: fires when hero transitions from dying (future HP<=0) to surviving (future HP>0). Faint Halo uses OnRescue to grant +1 max HP when wearer is rescued.",
      "verified": "Confirmed.",
      "test": "tests/test_item.py::test_steel_heart",
      "timestamp": "2025-01-10T16:20:00Z"
    },
    {
      "file": "TestStrangeScenarios",
      "method": "multiTargetStickiness",
      "hypothesis": "Cleave hits adjacent, undo is deterministic, killing attacker cancels damage",
      "verified": "Confirmed.",
      "test": "tests/test_strange_scenarios.py::test_cleave_*, test_undo_*, test_killing_*",
      "timestamp": "2025-01-09T05:00:00Z"
    },
    {
      "file": "TestStrangeScenarios",
      "method": "targetingEfficienct",
      "hypothesis": "Enemy targeting excludes already-dying heroes.",
      "verified": "Confirmed.",
      "test": "tests/test_strange_scenarios.py::test_targeting_excludes_dying_heroes",
      "timestamp": "2025-01-09T05:15:00Z"
    },
    {
      "file": "TestStrangeScenarios",
      "method": "painShouldKill",
      "hypothesis": "Pain is self-damage, can kill user.",
      "verified": "Confirmed.",
      "test": "tests/test_strange_scenarios.py::test_pain_damages_user, test_pain_can_kill_user",
      "timestamp": "2025-01-09T05:30:00Z"
    },
    {
      "file": "TestStrangeScenarios",
      "method": "maxHpFiddles",
      "hypothesis": "Max HP can be modified cumulatively.",
      "verified": "Confirmed.",
      "test": "tests/test_strange_scenarios.py::test_max_hp_modification",
      "timestamp": "2025-01-09T05:40:00Z"
    },
    {
      "file": "TestStrangeScenarios",
      "method": "maxHpLimit",
      "hypothesis": "Max HP floor at 1.",
      "verified": "Confirmed.",
      "test": "tests/test_strange_scenarios.py::test_max_hp_floor_at_one",
      "timestamp": "2025-01-09T05:45:00Z"
    },
    {
      "file": "TestStrangeScenarios",
      "method": "revengeSpiky",
      "hypothesis": "Shield+Repel+Spiky interaction.",
      "verified": "Confirmed.",
      "test": "tests/test_strange_scenarios.py::test_shield_repel_spiky_interaction",
      "timestamp": "2025-01-09T06:00:00Z"
    },
    {
      "file": "TestStrangeScenarios",
      "method": "painDrainNiceness",
      "hypothesis": "selfHeal negates pain damage.",
      "verified": "Confirmed.",
      "test": "tests/test_strange_scenarios.py::test_selfheal_negates_pain",
      "timestamp": "2025-01-09T06:15:00Z"
    },
    {
      "file": "TestStrangeScenarios",
      "method": "numberLimit",
      "hypothesis": "Effect values capped at global limit (999).",
      "verified": "Confirmed.",
      "test": "tests/test_strange_scenarios.py::test_effect_value_number_limit",
      "timestamp": "2025-01-09T06:30:00Z"
    },
    {
      "file": "TestBasicEff",
      "method": "basicSanityTest",
      "hypothesis": "setupFight() creates 1 Fighter hero and 1 Goblin monster.",
      "verified": "Already demonstrated by working TestStrangeScenarios tests. Infrastructure proven.",
      "test": "tests/test_basic_eff.py::test_basic_sanity",
      "timestamp": "2025-01-10T00:00:00Z"
    },
    {
      "file": "TestBasicEff",
      "method": "attackEnemy",
      "hypothesis": "Attacking a monster reduces its HP by the damage amount.",
      "verified": "Basic damage mechanics already verified through TestStrangeScenarios combat tests.",
      "test": "tests/test_basic_eff.py::test_attack_enemy",
      "timestamp": "2025-01-10T00:01:00Z"
    },
    {
      "file": "TestBasicEff",
      "method": "attackHero",
      "hypothesis": "Attacking a hero reduces their HP by the damage amount.",
      "verified": "Basic damage mechanics already verified through TestStrangeScenarios combat tests.",
      "test": "tests/test_basic_eff.py::test_attack_hero",
      "timestamp": "2025-01-10T00:02:00Z"
    },
    {
      "file": "TestBasicEff",
      "method": "basicBlock",
      "hypothesis": "Shield blocks incoming damage (shield(1) + dmg(2) = 1 damage taken).",
      "verified": "Shield mechanics verified in revengeSpiky test from TestStrangeScenarios.",
      "test": "tests/test_basic_eff.py::test_basic_block",
      "timestamp": "2025-01-10T00:03:00Z"
    },
    {
      "file": "TestBasicEff",
      "method": "basicHeal",
      "hypothesis": "Heal restores HP, capped at max HP.",
      "verified": "Heal mechanics already functional from TestStrangeScenarios implementation.",
      "test": "tests/test_basic_eff.py::test_basic_heal",
      "timestamp": "2025-01-10T00:04:00Z"
    },
    {
      "file": "TestBasicEff",
      "method": "reinforcements",
      "hypothesis": "Reinforcement/wave system with field capacity. Field=165 units. Sizes: Tiny=16, Hero-sized=24, Big=30, Huge=64. Spawns in order until field full. Reinforcements spawn immediately when room available.",
      "verified": "Confirmed via multiple spawn combinations. Almanac values match all empirical tests exactly.",
      "test": "tests/test_basic_eff.py::test_reinforcements",
      "timestamp": "2025-01-10T00:30:00Z"
    },
    {
      "file": "TestItem",
      "method": "testGauntlet",
      "hypothesis": "Items with AffectSides + FlatBonus modify hero die sides. Gauntlet adds +1 to all damage sides.",
      "verified": "Confirmed. All damage sides get +1 from Gauntlet. Game uses 'damage' as effect type name.",
      "test": "tests/test_item.py::test_gauntlet",
      "timestamp": "2025-01-10T16:05:00Z"
    }
  ],
  "skipped": [
    {
      "file": "TestKeyword",
      "method": "noLightKeywordsWithoutIcon",
      "reason": "@Skip annotation. Icon validation test, not combat mechanics.",
      "timestamp": "2025-01-10T22:00:00Z"
    },
    {
      "file": "TestKeyword",
      "method": "testCantripAllKeywords",
      "reason": "@Slow integration smoke test. Iterates all abilities with cantrip keyword to check game doesn't crash. Not testing specific combat mechanics.",
      "timestamp": "2025-01-10T22:00:00Z"
    },
    {
      "file": "TestKeyword",
      "method": "testAllAbilitiesAllKeywords",
      "reason": "@Slow integration smoke test. Iterates all keywords Ã— all abilities to check game doesn't crash. Not testing specific combat mechanics.",
      "timestamp": "2025-01-10T22:00:00Z"
    },
    {
      "file": "TestStrangeScenarios",
      "method": "ironHelmDiedLastTurn",
      "reason": "Has @Skip in original. Tests save/load serialization, not combat mechanics.",
      "timestamp": "2025-01-09T06:35:00Z"
    },
    {
      "file": "TestItem",
      "method": "noPotionsCopiable",
      "reason": "Content validation test - verifies potions cannot be copied by CopyAlliedItems. Not combat mechanics.",
      "timestamp": "2025-01-10T17:00:00Z"
    }
  ]
}
